theory Tuple_Array_Tuple imports "../Hex" "../AbiTypes" "../AbiDecode" "../AbiEncode" "../WordUtils"

begin

(* solidity *)

(*


 pragma experimental ABIEncoderV2;

 contract C {
    
    struct inner {
        uint256 i1;
        uint256 i2;
    }
     
    struct outer {
    inner [] o1;
    inner [] o2;
    inner [] o3;
    }
    
    inner [] elem1;
    inner [] elem2;
    inner [] elem3;
    

    function getEncoding() external returns (bytes memory) {
        
        elem1.push(inner(0,1));
        elem1.push(inner(2, 4));
        elem1.push(inner(40, 40));
        elem1.push(inner(9, 10));
        
        // elem2 empty
        
        elem3.push(inner(100, 101));
        elem3.push(inner(42, 43));

        return abi.encode( outer(elem1, elem2, elem3));
    }
}

*)

(* Hex output (raw) *)

(*
{
	"0": "bytes: 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000065000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b"
}
*)

(* hex output (trimmed) *)

(*
0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000065000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b
*)

definition test_in :: "8 word list" where
"test_in = hex_splits
''0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001a000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000065000000000000000000000000000000000000000000000000000000000000002a000000000000000000000000000000000000000000000000000000000000002b''"

definition inner :: abi_type where
"inner = Ttuple [Tuint 256, Tuint 256]"

definition middle :: abi_type where
"middle = Tarray inner"

definition test_schema :: abi_type where
"test_schema = Ttuple [middle, middle, middle]"

definition test_out :: abi_value where
"test_out = Vtuple [middle, middle, middle]
            [Varray inner [
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [0, 1]),
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [2, 4]),
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [40, 40]),
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [9, 10])],
             Varray inner [],
             Varray inner [
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [100, 101]),
              Vtuple [Tuint 256, Tuint 256] (map (Vuint 256) [42, 43])]]"
              

value "test_out"

value "decode test_schema test_in = Ok test_out"

value "encode test_out = Some test_in"

value "bytesToEvmWords test_in"

end